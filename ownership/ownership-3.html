<html class="background">

<head>
    <title>cr0wbar's Rust course - Ownership: stack & heap memory</title>
    <link rel="stylesheet" href="../static/stylesheet.css">
    <link rel="shortcut_icon" type="image/png" href="../static/shocked_hugh.ico">
    <link rel="apple-touch-icon" href="../static/shocked_hugh.png">
    <link rel="icon" type="image/x-icon" href="../static/shocked_hugh.ico">
</head>

<body>

<div class="navbar">
    <a href="https://fyp.cr0wbar.dev">Homepage</a>
    <a href="https://fyp.cr0wbar.dev/login">Login</a>
</div>

<div class="box">

<div class="titles">
    <h1 class="header">
        Stack Memory & Heap Memory
    </h1>

    <h3 class="subheader">

    </h3>
</div>

<div class="info">
    <p>
        Like for most programming languages, the Rust runtime manages its stored variables, functions, macros and other such pieces of data in two distinct areas of memory: <b>stack</b> memory and <b>heap</b> memory.
    </p>
</div>

<div class="info">
    <p>
        Whether a variable is stored in the stack or in the heap depends on its data type, particularly, <em>whether the size of a variable of that data type can be known at compile-time</em>.
    </p>
</div>

<div class="info">
    <p>
        Learning this distinction may seem daunting, but understanding it will also further understanding of Rust's ownership system, since memory management is handled with ownership in such a way 
        that most Rust programmers won't need to concern themselves with it, even without a garbage collector.
    </p>
</div>

<div class="info">
    <p>
        Stack memory:
        <ul class="list">
            <li>is a <b>last-in-first-out (LIFO)</b> memory space; for some value to be removed, every value that entered after it must be removed first</li>
            <li>stores values with sizes that are <b>already known</b> and <b>are unchangeable</b></li>
            <li><em>pushes</em> (inserts) values when assigned and <em>pops</em> (removes) them from the stack when they're destructed</li>
            <li>push & pop operations are very fast, as the position from which to add or remove never changes</li>
        </ul>
    </p>
</div>

<div class="animbox">
    <p>
        <img src="../static/stack.gif">
    </p>
</div>

<div class="info">
    <p>
        Heap memory:
        <ul class="list">
            <li>is a less structured, more open memory space</li>
            <li>stores values with <b>unknown initial sizes</b> that <b>may change during execution</b></li>
            <li>space is <b>allocated and deallocated</b> instead of pushed and popped</li>
            <li>allocation is slower and more expensive than stack operations, as the runtime constantly needs to distinguish between used memory and free memory</li>
        </ul>
    </p>
</div>

<div class="info">
    <p>
        <b>W.I.P. - Animation demonstrating a struct being allocated to, and being deallocated from, the heap, goes here</b>
    </p>
</div>

<div class="info">
    <p>
        As mentioned on the previous page, C and C++ allow programmers to handle memory manually. More specifically, C allows programmers to manually <em>allocate, reallocate and deallocate spaces on the heap</em>. 
    </p>
</div>

<div class="info">
    <p>
        Rust, on the other hand, will automatically perform these operations on the heap, depending on the ownership status of a value.
    </p>
</div>

<div class="info">
    <p>
        Recall the two string data types mentioned in the last chapter: since String structs are <em>mutable</em>, they are allocated in heap memory, whereas string slices (explained in more detail on the next page) are <em>immutable</em>, and pushed to the stack during execution.
    </p>
</div>

<div class="info">
    <p>
        Specifically, String structs are allocated on the heap during their lifetimes, but the actual body of the string is <em>stored on the stack</em>, and the struct has a memory pointer to the first character of the string.
    </p>
    <p class="inlinelink"><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A%0A++++%2F%2F%2F+The+below+string+struct+is+built+using+from%28%29%2C%0A++++%2F%2F%2F+a+built-in+method+that+attempts+to+convert+%0A++++%2F%2F%2F+a+variable+of+one+type+into+another+type.%0A++++%2F%2F%2F+%0A++++%2F%2F%2F+Here%2C+a+string+literal+%28a.k.a.+a+value+of+type+%26str%29%0A++++%2F%2F%2F+is+pushed+onto+the+stack+character+by+character%2C+%0A++++%2F%2F%2F+and+the+struct+is+then+allocated+in+%0A++++%2F%2F%2F+heap+memory+and+has+its+pointer+set+to+the+string+literal.%0A++++%0A++++let+str_struct+%3D+String%3A%3Afrom%28%22This+is+a+struct%21%22%29%3B%0A++++%0A%7D" target="_blank">
        fn main() {<br/>
            <br/>
        &nbsp;/// The below string struct is built using from(),<br/>
        &nbsp;/// a built-in method that attempts to convert <br/>
        &nbsp;/// a variable of one type into another type.<br/>
        &nbsp;/// <br/>
        &nbsp;/// Here, a string literal (a.k.a. a value of type &str)<br/>
        &nbsp;/// is pushed onto the stack character by character, <br/>
        &nbsp;/// and the struct is then allocated in <br/>
        &nbsp;/// heap memory and has its pointer set to the string literal.<br/>
        <br/>
        &nbsp;let str_struct = String::from("This is a struct!");<br/>
        <br/>
        }
    </a></p>
</div>

<div class="info">
    <p>
        When the struct is assigned a new set of characters, these characters are simply pushed onto the stack, and the String struct's pointer is moved to those new characters. The old sequence of characters subsequently goes out of scope, and is eventually popped from the stack.
    </p>
    <p class="inlinelink"><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A%0A++++%2F%2F%2F+When+the+below+struct+is+given%0A++++%2F%2F%2F+a+new+value+on+the+second+line%2C+%0A++++%2F%2F%2F+its+pointer+is+moved+to+the+new+%0A++++%2F%2F%2F+string+literal%2C+and+the+previous%0A++++%2F%2F%2F+string+literal+goes+out+of+scope.%0A++++%0A++++let+mut+str_struct+%3D+String%3A%3Afrom%28%22This+is+a+struct%21%22%29%3B%0A++++%0A++++str_struct+%3D+String%3A%3Afrom%28%22This+is+a+new+string%21%22%29%3B%0A++++%0A%7D" target="_blank">
        fn main() {<br/>
            <br/>
        &nbsp;/// When the below struct is given<br/>
        &nbsp;/// a new value on the second line, <br/>
        &nbsp;/// its pointer is moved to the new <br/>
        &nbsp;/// string literal, and the previous<br/>
        &nbsp;/// string literal goes out of scope.<br/>
            <br/>
        &nbsp;let mut str_struct = String::from("This is a struct!");<br/>
            <br/>
        &nbsp;str_struct = String::from("This is a new string!");<br/>
        <br/>
        }
    </a></p>
</div>

<div class="info">
    <p>
        However, in the case of one String struct being assigned to another, the one taking the value will have its pointer moved to the <em>same memory as the struct being assigned</em>. This is to save memory, and prevent bloat on the stack.
    </p>
    <p class="inlinelink"><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A%0A++++%2F%2F%2F+Assigning+the+first+variable%0A++++%2F%2F%2F+to+the+second+will+move+ownership%0A++++%2F%2F%2F+of+the+first%2C+making+it+inaccessible%2C%0A++++%2F%2F%2F+but+will+also+cause+both+structs+to%0A++++%2F%2F%2F+point+to+the+same+sequence+of+memory%0A++++%2F%2F%2F+cells+on+the+stack.%0A%0A++++let+str_struct+%3D+String%3A%3Afrom%28%22This+is+a+struct%21%22%29%3B%0A++++%0A++++let+second_struct+%3D+str_struct%3B%0A++++%0A%7D" target="_blank">
        fn main() {<br/>
            <br/>
        &nbsp;/// Assigning the first variable<br/>
        &nbsp;/// to the second will move ownership<br/>
        &nbsp;/// of the first, making it inaccessible,<br/>
        &nbsp;/// but will also cause both structs to<br/>
        &nbsp;/// point to the same sequence of memory<br/>
        &nbsp;/// cells on the stack.<br/>
            <br/>
        &nbsp;let str_struct = String::from("This is a struct!");<br/>
            <br/>
        &nbsp;let second_struct = str_struct;<br/>
            <br/>
        }
    </a></p>
</div>

<div class="info">
    <p>
        Values stored exclusively on the stack are known by the compiler to never change in storage size during execution, such as integers, booleans and single characters. However, if these need to be stored in a dynamic context for whatever reason, Rust offers a <em>generic</em> (explained later) called <b>Box&lt;&gt;.</b>
    </p>
</div>

<div class="info">
    <p>
        The Box generic allocates heap memory for a given variable, before pushing a pointer to this memory space onto the stack. A variable is said to be <b>boxed</b> if it is being explicitly stored on the heap using this generic, when it would normally be stored on the stack.
    </p>
</div>

<div class="info">
    <p>
        <b>W.I.P. - Animation of boxed integer being created goes here</b>
    </p>
</div>

</div>

<div class="nav">
    <a href="https://fyp.cr0wbar.dev/ownership/2">&laquo; References</a>
    <a href="https://fyp.cr0wbar.dev/ownership/4">Slices &raquo;</a>
</div>

</body>

<audio autoplay id="mouseclick">
    <source src="../static/mouse-click.mp3" type="audio/mpeg">
    <source src="../static/mouse-click.ogg" type="audio/ogg">
</audio>

</html>
